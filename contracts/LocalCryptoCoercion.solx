pragma solidity ^0.4.18;

import "./Secp256k1.sol";

contract LocalCryptoVoteSelling {

    // Modulus for public keys
    uint constant pp = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;

    // Base point (generator) G
    uint constant Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;
    uint constant Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;

    // Modulus for private keys (sub-group)
    uint constant nn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;

    uint[2] G;

    function LocalCryptoVoteSelling() {
        G[0] = Gx;
        G[1] = Gy;
    }

    function legendreSymbol(uint a, uint p) returns (int) {
        uint ls = ECCMath.expmod(a, (p - 1) / 2, p);
        if (ls == p - 1) {
            return -1;
        } else {
            return int(ls);
        }
    }

    function sqrtmod(uint a, uint p) returns (uint) {
        if (legendreSymbol(a, p) != 1) {
            return 0;
        } else if (a == 0) {
            return 0;
        } else if (p == 2) {
            return p;
        } else if (p % 4 == 3) {
            return ECCMath.expmod(a, (p + 1) / 4, p);
        }

        uint s = p - 1;
        uint e = 0;
        while (s % 2 == 0) {
            s /= 2;
            e += 1;
        }

        uint n = 2;
        while (legendreSymbol(n, p) != -1) {
            n += 1;
        }
        uint x = ECCMath.expmod(a, (s + 1) / 2, p);
        uint b = ECCMath.expmod(a, s, p);
        uint g = ECCMath.expmod(n, s, p);
        uint r = e;

        while (true) {
            uint t = b;
            for (uint m = 0; m < r; m++) {
                if (t == 1) {
                    break;
                }
                t = ECCMath.expmod(t, 2, p);
            }

            if (m == 0) {
                return x;
            }
            uint gs = ECCMath.expmod(g, 2 ** (r - m - 1), p);
            g = (gs * gs) % p;
            x = (x * gs) % p;
            b = (b * g) % p;
            r = m;
        }
    }

    function mapToCurve(uint x) returns (uint[2]) {
        x -= 1;
        uint y;
        uint f_x;

        while (true) {
            x = (x + 1) % pp;
            f_x = (x * x * x + 7) % pp;
            y = sqrtmod(f_x, pp);
            if (y != 0) {
                return [x, y];
            }
        }
    }

    // a - b = c;
    function submod(uint a, uint b) returns (uint){
        uint a_nn;

        if(a>b) {
          a_nn = a;
        } else {
          a_nn = a+nn;
        }

        uint c = addmod(a_nn - b,0,nn);

        return c;
    }

    function createZKPPublicKeys(uint[] publicKeys, uint[2] H, uint w, uint[] r, uint[] d, uint x, uint g, uint proverIndex) returns (uint[2], uint[], uint[], uint[], uint[]){
        require(r.length == d.length && publicKeys.length/2 == r.length);
        uint[] memory a = new uint[](publicKeys.length);
        uint[] memory b = new uint[](publicKeys.length);
        uint[2] memory y;
        uint dSum;

        // y = h^{x}
        uint[3] memory temp1 = Secp256k1._mul(x, H);
        ECCMath.toZ1(temp1, pp);

        // Store y_x and y_y
        y[0] = temp1[0];
        y[1] = temp1[1];

        for (uint i = 0; i < r.length; i++) {
            if (i == proverIndex) {
                temp1 = Secp256k1._mul(w, H);
                ECCMath.toZ1(temp1, pp);

                a[i*2] = temp1[0];
                a[i*2+1] = temp1[1];

                temp1 = Secp256k1._mul(w, G);
                ECCMath.toZ1(temp1, pp);

                b[i*2] = temp1[0];
                b[i*2+1] = temp1[1];
            } else {
                temp1 = Secp256k1._mul(r[i], H);
                temp1 = Secp256k1._add(temp1, Secp256k1._mul(d[i], y));
                ECCMath.toZ1(temp1, pp);

                a[i*2] = temp1[0];
                a[i*2+1] = temp1[1];

                temp1 = Secp256k1._mul(r[i], G);
                temp1 = Secp256k1._add(temp1, Secp256k1._mul(d[i], [publicKeys[i*2], publicKeys[i*2+1]]));
                ECCMath.toZ1(temp1, pp);

                b[i*2] = temp1[0];
                b[i*2+1] = temp1[1];

                dSum = addmod(dSum, d[i], nn);
            }
        }

        bytes32 b_c = sha256(msg.sender, H, y, a, b);

        // d1 = c - d_sum mod q
        d[proverIndex] = submod(uint(b_c), dSum);

        // r1 = w - (x * d1)
        r[proverIndex] = submod(w, mulmod(x, temp1[0], nn));

        return (y, a, b, d, r);
    }

    function computeRealStep (uint w, uint base1, uint base2) {

    }

    function createZKPVotes (uint[] votes, uint[] recomputedBases, uint[2] H, uint w, uint[] params, uint x, uint proverIndex) returns (uint[2], uint[], uint[]) {
        require(params.length == votes.length && votes.length == params.length && recomputedBases.length == params.length);
        uint[] memory res = new uint[](votes.length*2);
        uint[2] memory y;
        uint dSum;

        // y = h^{x}
        uint[3] memory temp1 = Secp256k1._mul(x, H);
        ECCMath.toZ1(temp1, pp);

        // Store y_x and y_y
        y[0] = temp1[0];
        y[1] = temp1[1];

        for (uint i = 0; i < params.length/2; i++) {
            if (i == proverIndex) {
                temp1 = Secp256k1._mul(w, H);
                ECCMath.toZ1(temp1, pp);

                res[i*4] = temp1[0];
                res[i*4+1] = temp1[1];

                temp1 = Secp256k1._mul(w, [recomputedBases[i*2], recomputedBases[i*2+1]]);
                ECCMath.toZ1(temp1, pp);

                res[i*4+2] = temp1[0];
                res[i*4+3] = temp1[1];
            } else {
                temp1 = Secp256k1._mul(params[i*2+1], H);
                temp1 = Secp256k1._add(temp1, Secp256k1._mul(params[i*2], y));
                ECCMath.toZ1(temp1, pp);

                res[i*4] = temp1[0];
                res[i*4+1] = temp1[1];

                temp1 = Secp256k1._mul(params[i*2+1], G);
                temp1 = Secp256k1._add(temp1, Secp256k1._mul(params[i*2], [votes[i*2], votes[i*2+1]]));
                ECCMath.toZ1(temp1, pp);

                res[i*4+2] = temp1[0];
                res[i*4+3] = temp1[1];

                dSum = addmod(dSum, params[i*2], nn);
            }
        }

        // d_prover_index = c - d_sum mod q
        params[proverIndex*2] = submod(uint(sha256(msg.sender, H, y, res)), dSum);

        // r_prover_index = w - (x * d_prover_index) mod q
        params[proverIndex*2+1] = submod(w, mulmod(x, temp1[0], nn));

        return (y, res, params);
    }

}
